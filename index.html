<!DOCTYPE html>
<meta charset="utf-8">
<style>

text {
  font: 10px sans-serif;
}

svg {
  font: 10px sans-serif;
}

circle {
  -webkit-transition: fill-opacity 250ms linear;
}

.selecting circle {
  fill-opacity: .2;
}

.selecting circle.selected {
  stroke: #f00;
}

.resize path {
  fill: #666;
  fill-opacity: .8;
  stroke: #000;
  stroke-width: 1.5px;
}

.axis path, .axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.brush .extent {
  fill-opacity: .125;
  shape-rendering: crispEdges;
}


/*
.axis text {
  font: 11px sans-serif;
}

.axis path {
  display: none;
}

.axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.grid-background {
  fill: #ddd;
}

.grid line,
.grid path {
  fill: none;
  stroke: #fff;
  shape-rendering: crispEdges;
}

.grid .minor.tick line {
  stroke-opacity: .5;
}

.brush .extent {
  stroke: #000;
  fill-opacity: .125;
  shape-rendering: crispEdges;
}
*/
</style>
<body>
    <script src="https://d3js.org/d3.v3.min.js"></script>
<script>

var minFreq = 5000;
var maxFreq = 150000;

var diameter = 960,
        format = d3.format(",d"),
        color = d3.scale.category20c();

    var bubble = d3.layout.pack()
        .sort(null)
        .size([diameter, diameter])
        .padding(1.5);

    var svg1 = d3.select("body").append("svg")
        .attr("width", diameter)
        .attr("height", diameter)
        .attr("class", "bubble");

    
    

function update() {
      // everytime update() is called, we (re)compute the layout, using the
      // previously provided value function
    
    svg1.selectAll("*").remove();


    d3.json("FullData", function(error, root) {
          if (error) throw error;
        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

    var node = svg1.selectAll(".node")
        .data(bubble.nodes(classes(root))
        .filter(function(d) { return !d.children && d.value <= maxFreq && minFreq <= d.value; }))
        //.filter(function(d) { return d.value <= maxFreq && minFreq <= d.value; }))
        .enter().append("g")
        .attr("class", "node")
        .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });

    node.append("title")
        .text(function(d) { return d.className + ": " + format(d.value); });
  /*node.append("pattern")
    .attr('id', function(d) { return (d.className.replace(/ /g,'')+"-icon");}) // just create a unique id (id comes from the json)
    .attr('width', 1)
    .attr('height', 1)
    .attr('patternContentUnits', 'objectBoundingBox')
    .append("svg:image")
      .attr("xlink:xlink:href", function(d) { return (d.url);}) //The double xlink:xlink is a necessary hack (first "xlink:" is lost...).
      .attr("x", 0)
      .attr("y", 0)
      .attr("height", 1)
      .attr("width", 1)
      .attr("preserveAspectRatio", "xMinYMin slice");*/
   
      node.append("circle")
          .attr("r", function(d) { return d.r; })
          //.style("stroke", "black")     
        .style("fill", function(d) { return color(getRandomInt(0,20)); })
       // .style("fill", function(d) { return ("url(#"+d.className.replace(/ /g,'')+"-icon)");})


      node.append("text")
          .attr("dy", ".3em")
          .style("text-anchor", "middle")
          .text(function(d) { return d.className.substring(0, d.r / 3); });
    });

    // Returns a flattened hierarchy containing all leaf nodes under the root.
    function classes(root) {
      var classes = [];

      function recurse(name, node) {
        if (node.children) node.children.forEach(function(child) { recurse(node.name, child); });
        else classes.push({packageName: name, className: node.name, value: node.size, url: node.url});
      }

      recurse(null, root);
      return {children: classes};
    }
}

    update(); // on initial page loading, use update() to show the visualization


var margin = {top: 194, right: 50, bottom: 214, left: 50},
    width = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;

var x = d3.scale.log()
    .domain([Math.pow(10, 0), Math.pow(10, 6)])
    .range([0, width]);

var y = d3.random.normal(height / 2, height / 8);

var brush = d3.svg.brush()
    .x(x)
    .extent([minFreq, maxFreq])
    .on("brushstart", brushstart)
    .on("brush", brushmove)
    .on("brushend", brushend);

var arc = d3.svg.arc()
    .outerRadius(height / 4)
    .startAngle(0)
    .endAngle(function(d, i) { return i ? -Math.PI : Math.PI; });

var svg = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
    .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

svg.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(d3.svg.axis().scale(x).orient("bottom"));


var brushg = svg.append("g")
    .attr("class", "brush")
    .call(brush);

brushg.selectAll(".resize").append("path")
    .attr("transform", "translate(0," +  height / 2 + ")")
    .attr("d", arc);

brushg.selectAll("rect")
    .attr("height", height);

brushstart();
brushmove();

function brushstart() {
  svg.classed("selecting", true);
}

function brushmove() {
  var s = brush.extent();
  minFreq = s[0];
  maxFreq = s[1];
}

function brushend() {
  svg.classed("selecting", !d3.event.target.empty());
  update();
}

 //date slider
/*
d3.select(self.frameElement).style("height", diameter + "px");

var margin = {top: 200, right: 40, bottom: 200, left: 40},
    width = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;

var x = d3.time.scale(d3.time.hour, 1)
    .domain([new Date(2013, 2, 1), new Date(2013, 2, 15) - 1])
    .range([0, width]);

var brush = d3.svg.brush()
    .x(x)
    .extent([new Date(2013, 2, 2), new Date(2013, 2, 3)])
    .on("brush", brushed);

var svg = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

svg.append("rect")
    .attr("class", "grid-background")
    .attr("width", width)
    .attr("height", height);

svg.append("g")
    .attr("class", "x grid")
    .attr("transform", "translate(0," + height + ")")
    .call(d3.svg.axis()
        .scale(x)
        .orient("bottom")
        .ticks(d3.time.hours, 12)
        .tickSize(-height)
        .tickFormat(""))
  .selectAll(".tick")
    .classed("minor", function(d) { return d.getHours(); });

svg.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(d3.svg.axis()
      .scale(x)
      .orient("bottom")
      .ticks(d3.time.days)
      .tickPadding(0))
  .selectAll("text")
    .attr("x", 6)
    .style("text-anchor", null);

var gBrush = svg.append("g")
    .attr("class", "brush")
    .call(brush);

gBrush.selectAll("rect")
    .attr("height", height);

function brushed() {
  var extent0 = brush.extent(),
      extent1;

  // if dragging, preserve the width of the extent
  if (d3.event.mode === "move") {
    var d0 = d3.time.day.round(extent0[0]),
        d1 = d3.time.day.offset(d0, Math.round((extent0[1] - extent0[0]) / 864e5));
    extent1 = [d0, d1];
  }

  // otherwise, if resizing, round both dates
  else {
    extent1 = extent0.map(d3.time.day.round);

    // if empty when rounded, use floor & ceil instead
    if (extent1[0] >= extent1[1]) {
      extent1[0] = d3.time.day.floor(extent0[0]);
      extent1[1] = d3.time.day.ceil(extent0[1]);
    }
  }

  d3.select(this).call(brush.extent(extent1));
}
*/



</script>
