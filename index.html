<!DOCTYPE html>
<meta charset="utf-8">
<style>

text {
  font: 10px sans-serif;
}

svg {
  font: 10px sans-serif;
}

circle {
  -webkit-transition: fill-opacity 250ms linear;
}

.selecting circle {
  fill-opacity: .2;
}

.selecting circle.selected {
  stroke: #f00;
}

.resize path {
  fill: #666;
  fill-opacity: .8;
  stroke: #000;
  stroke-width: 1.5px;
}

.axis path, .axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.brush .extent {
  fill-opacity: .125;
  shape-rendering: crispEdges;
}
svg:nth-of-type(2) {
  float: right;
  position: absolute;
}
.domain {
  fill: none;
  stroke: #000;
  stroke-opacity: .3;
  stroke-width: 10px;
  stroke-linecap: round;
}
.tick {
  font-size: 10px;
}
.selecting circle {
  fill-opacity: .2;
}
.selecting circle.selected {
  stroke: #f00;
}
.handle {
  fill: #fff;
  stroke: #000;
  stroke-opacity: .5;
  stroke-width: 1.25px;
  cursor: crosshair;
}
/*
.axis text {
  font: 11px sans-serif;
}

.axis path {
  display: none;
}

.axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.grid-background {
  fill: #ddd;
}

.grid line,
.grid path {
  fill: none;
  stroke: #fff;
  shape-rendering: crispEdges;
}

.grid .minor.tick line {
  stroke-opacity: .5;
}

.brush .extent {
  stroke: #000;
  fill-opacity: .125;
  shape-rendering: crispEdges;
}
*/
</style>
<body>
    <script src="https://d3js.org/d3.v3.min.js"></script>
<script>

var minFreq = 5000;
var maxFreq = Math.pow(10, 5);

var maxSize = 1570;
var elementSize = maxSize;

var diameter = 960,
        format = d3.format(",d"),
        color = d3.scale.category20();

    var bubble = d3.layout.pack()
        .sort( function(a, b) 
        {
          var threshold = Math.pow(10, 6);
          if ((a.value > threshold) && (b.value > threshold)) {
              return -(a.value - b.value);
          } else {
              return -1;
          }
        })
        .size([diameter, diameter])
        .padding(1.5);

    var svg1 = d3.select("body").append("svg")
        .attr("width", diameter)
        .attr("height", diameter)
        .attr("class", "bubble");

  var colorScale = d3.scale.log()
      .domain([Math.pow(10, 0), Math.pow(10, 5)])
      .range([d3.rgb(255,255,255), d3.rgb(100,55,235)]);


    
    
    

function update() {
      // everytime update() is called, we (re)compute the layout, using the
      // previously provided value function
    
    svg1.selectAll("*").remove();

    d3.json("FullDataTags", function(error, root) {
          if (error) throw error;
        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
    var elements = classes(root);
    if (elementSize != maxSize) 
    {
      elements.children = elements.children.splice(0,elementSize);
    }
    var laidOut = bubble.nodes(elements);

    var node = svg1.selectAll(".node")
        .data(laidOut
        .filter(function(d) { return !d.children && d.value <= maxFreq && minFreq <= d.value; }))
        //.filter(function(d) { return d.value <= maxFreq && minFreq <= d.value; }))
        .enter().append("g")
        .attr("class", "node")
        .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });

    node.append("title")
        .text(function(d) { return d.className + ": " + format(d.value); });
  /*node.append("pattern")
    .attr('id', function(d) { return (d.className.replace(/ /g,'')+"-icon");}) // just create a unique id (id comes from the json)
    .attr('width', 1)
    .attr('height', 1)
    .attr('patternContentUnits', 'objectBoundingBox')
    .append("svg:image")
      .attr("xlink:xlink:href", function(d) { return (d.url);}) //The double xlink:xlink is a necessary hack (first "xlink:" is lost...).
      .attr("x", 0)
      .attr("y", 0)
      .attr("height", 1)
      .attr("width", 1)
      .attr("preserveAspectRatio", "xMinYMin slice");*/
   
      node.append("circle")
          .attr("r", function(d) { return d.r; })
          //.style("stroke", "black")     
        .style("fill", function(d) { return color(getRandomInt(0,20)); })
       // .style("fill", function(d) { return ("url(#"+d.className.replace(/ /g,'')+"-icon)");})


      node.append("text")
          .attr("dy", ".3em")
          .style("text-anchor", "middle")
          .text(function(d) { return d.className.substring(0, d.r / 3); });
    });

    // Returns a flattened hierarchy containing all leaf nodes under the root.
    function classes(root) {
      var classes = [];

      function recurse(name, node) {
        if (node.children) node.children.forEach(function(child) { recurse(node.name, child); });
        else classes.push({packageName: name, className: node.name, value: node.size, url: node.url, 
        HourOfDay:{"freq": node.HourOfDay.freq, "time": node.HourOfDay["time"]}, 
        device: {"name": node.device["name"], "num": node.device.num},
        season: {"name": node.season["name"], "freq": node.season.freq}});
      }

      recurse(null, root);
      return {children: classes};
    }
}

    update(); // on initial page loading, use update() to show the visualization


var margin = {top: 194, right: 50, bottom: 214, left: 50},
    width = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;

var x = d3.scale.log()
    .domain([Math.pow(10, 0), Math.pow(10, 5)])
    .range([0, width]);

var y = d3.random.normal(height / 2, height / 8);

var brush = d3.svg.brush()
    .x(x)
    .extent([minFreq, maxFreq])
    .on("brushstart", brushstart)
    .on("brush", brushmove)
    .on("brushend", brushend);

var arc = d3.svg.arc()
    .outerRadius(height / 4)
    .startAngle(0)
    .endAngle(function(d, i) { return i ? -Math.PI : Math.PI; });

var svg = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
    .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

svg.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(d3.svg.axis().scale(x).orient("bottom"));


var brushg = svg.append("g")
    .attr("class", "brush")
    .call(brush);

brushg.selectAll(".resize").append("path")
    .attr("transform", "translate(0," +  height / 2 + ")")
    .attr("d", arc);

brushg.selectAll("rect")
    .attr("height", height);

brushstart();
brushmove();

function brushstart() {
  svg.classed("selecting", true);
}

function brushmove() {
  var s = brush.extent();
  minFreq = s[0];
  maxFreq = s[1];
}

function brushend() {
  svg.classed("selecting", !d3.event.target.empty());
  update();
}
//second filter percentage
var xScale = d3.scale.linear()
    .domain([1, 100]) //phyiscal inputed values
    .range([1,900]) //outputed numbers
    .clamp(true)
var xAxis = d3.svg.axis()
    .scale(xScale)
    .tickSize(0)
    .tickPadding(15)
var slidercontainer = svg.append("g")
  .attr("transform", "translate(0, 10)")

var axis = slidercontainer.append("g")
  .call(xAxis) 
var brushPercentage = d3.svg.brush()
      .x(xScale)
      .extent([0, 100])
      .on("brush", brushedUpdateNum)
      .on("brushend", brushedUpdate)
  var slider = slidercontainer.append("g")
    .call(brushPercentage)
    .classed("slider", true)
  slider.selectAll(".extent,.resize")
      .remove();
  //circle manipulaters
  var handle=  slider.append("circle")
      .attr("r", 10)
      .attr("fill", "Red")
      .classed("handle", true)
      .attr("transform", "translate(0,0)")
    d3.select(".domain")
      .select(function() {return this.parentNode.appendChild(this.cloneNode(true))})
      .classed("halo", true)
  slider
      .call(brushPercentage.event)
    .transition() // gratuitous intro!
      .duration(750)
      .call(brushPercentage.extent([0, 100]))
      .call(brushPercentage.event); 
   function brushedUpdateNum () {
    var value = brush.extent()[0];
    if (d3.event.sourceEvent) { // not a programmatic event
      value = xScale.invert(d3.mouse(this)[0]);
      elementSize = (value.toFixed(0)/100*maxSize).toFixed(0);
      brush.extent([value, value]);
    }
    handle.attr("cx", xScale(value));
  }         
  function brushedUpdate () {
    var value = brush.extent()[0];
    if (d3.event.sourceEvent) { // not a programmatic event
      value = xScale.invert(d3.mouse(this)[0]);
      elementSize = (value.toFixed(0)/100*maxSize).toFixed(0);
      brush.extent([value, value]);
      update();
    }
    handle.attr("cx", xScale(value));
  }        
 //date slider
/*
d3.select(self.frameElement).style("height", diameter + "px");

var margin = {top: 200, right: 40, bottom: 200, left: 40},
    width = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;

var x = d3.time.scale(d3.time.hour, 1)
    .domain([new Date(2013, 2, 1), new Date(2013, 2, 15) - 1])
    .range([0, width]);

var brush = d3.svg.brush()
    .x(x)
    .extent([new Date(2013, 2, 2), new Date(2013, 2, 3)])
    .on("brush", brushed);

var svg = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

svg.append("rect")
    .attr("class", "grid-background")
    .attr("width", width)
    .attr("height", height);

svg.append("g")
    .attr("class", "x grid")
    .attr("transform", "translate(0," + height + ")")
    .call(d3.svg.axis()
        .scale(x)
        .orient("bottom")
        .ticks(d3.time.hours, 12)
        .tickSize(-height)
        .tickFormat(""))
  .selectAll(".tick")
    .classed("minor", function(d) { return d.getHours(); });

svg.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(d3.svg.axis()
      .scale(x)
      .orient("bottom")
      .ticks(d3.time.days)
      .tickPadding(0))
  .selectAll("text")
    .attr("x", 6)
    .style("text-anchor", null);

var gBrush = svg.append("g")
    .attr("class", "brush")
    .call(brush);

gBrush.selectAll("rect")
    .attr("height", height);

function brushed() {
  var extent0 = brush.extent(),
      extent1;

  // if dragging, preserve the width of the extent
  if (d3.event.mode === "move") {
    var d0 = d3.time.day.round(extent0[0]),
        d1 = d3.time.day.offset(d0, Math.round((extent0[1] - extent0[0]) / 864e5));
    extent1 = [d0, d1];
  }

  // otherwise, if resizing, round both dates
  else {
    extent1 = extent0.map(d3.time.day.round);

    // if empty when rounded, use floor & ceil instead
    if (extent1[0] >= extent1[1]) {
      extent1[0] = d3.time.day.floor(extent0[0]);
      extent1[1] = d3.time.day.ceil(extent0[1]);
    }
  }

  d3.select(this).call(brush.extent(extent1));
}
*/



</script>
